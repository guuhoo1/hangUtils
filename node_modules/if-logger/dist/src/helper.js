"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.multiArgsHandler = exports.isGo = exports.buildPrintLog = void 0;
var utils_1 = require("./utils");
var setting_1 = require("./setting");
function buildPrintLog(level, prop) {
    return function printLog() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this) {
            throw Error('`this` is undefined. Do you ever pass `logger.XXXX` as a parameter? Then the `this` binding is required.');
        }
        if (!isGo(this.options, level)) {
            return;
        }
        if (typeof args[0] === 'function') {
            var result_1 = args[0](utils_1.useFormat(level, this.options.tags, this.options.format), level, this.options.tags, utils_1.getHeaderString(__spreadArrays([level], this.options.tags)));
            return this.options.returnValue ? result_1 : undefined;
        }
        if (args.length > 1 || typeof args[0] === 'object') {
            var result_2 = multiArgsHandler(this.options.format, level, this.options.tags, args);
            return this.options.returnValue ? result_2 : undefined;
        }
        var message = this.options.format(level, this.options.tags, args[0]);
        var timeLabel = '[' + level + '] ' + args[0];
        if (prop === 'time') {
            this.timeMgr.time(timeLabel);
            return;
        }
        var time;
        if (prop === 'timeEnd') {
            time = this.timeMgr.timeEnd(timeLabel);
            if (time === undefined) {
                return;
            }
            message = message + ' ' + time + 'ms';
        }
        var result = this.options.transports.map(function (transport) {
            return transport(level, args[0], message, time, _this.options.timeEndLimit);
        });
        return this.options.returnValue ? result : undefined;
    };
}
exports.buildPrintLog = buildPrintLog;
function isGo(options, level) {
    var optionLevel = typeof options.level === 'function' ? options.level() : options.level;
    if (setting_1.LOG_LEVEL[optionLevel].priority < setting_1.LOG_LEVEL[level].priority) {
        return false;
    }
    if (options.levelFilter.length > 0 && !options.levelFilter.includes(level)) {
        return false;
    }
    if (options.tagFilter.length > 0 && !options.tagFilter.some(function (tag) { return options.tags.includes(tag); })) {
        return false;
    }
    if (options.pred !== undefined) {
        if (typeof options.pred === 'function') {
            return options.pred();
        }
        return options.pred;
    }
    return true;
}
exports.isGo = isGo;
function multiArgsHandler(format, level, tags, args) {
    if (tags === void 0) { tags = []; }
    var header = format(level, tags, '').trim();
    var result = utils_1.isNode()
        ? __spreadArrays([header], args).map(function (param) { return utils_1.getNodeColorMessage(level, param); })
        : __spreadArrays(utils_1.getColorMessage(level, header), args); // In browser, It can be applied `formatting` to only the first argument
    console[console[level] ? level : 'log'].apply(// In browser, It can be applied `formatting` to only the first argument
    console, result);
    return result;
}
exports.multiArgsHandler = multiArgsHandler;
//# sourceMappingURL=helper.js.map